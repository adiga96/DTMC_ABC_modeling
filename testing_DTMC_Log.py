%load_ext autotime
import numpy as np
import pandas as pd
import math
from scipy import random
from scipy import stats
import statistics
import matplotlib.pyplot as plt
import pickle

# Data Type 1
data_1 = pd.read_csv('//Users/pritishsadiga/Desktop/MS_Thesis/Data_Testing/data_test.csv')
# Data Type 2
data = pd.read_csv('/Users/pritishsadiga/Desktop/MS_Thesis/Data_Testing/data.csv')

observed_values = [data['hospitalized'].tolist(),
                    data['Critical'].tolist(),
                    data['recovered'].tolist(),
                    data['death'].tolist()]

def Trans_Matrix1(x,y):

    A = np.random.uniform(low = x, high = y)

    B_UL = 1 - A
    B_LL = 0
    B = np.random.uniform(low = B_LL , high = B_UL)

    C_UL = 1 - (A + B)
    C_LL = 0
    C = np.random.uniform(low = C_LL, high = C_UL)

    total_sum = A + B + C
    D = 1 - total_sum

    row_values = [A, B, C, D]

    return row_values
  
 # To calculate the rate of increase of cases from March 1 to March 17
data_copy = data
data_filter = data_copy[['hospitalized']][15:] #since 0-13 all values are zero
data_filter = data_filter.reset_index(drop = True)
mylist = data_filter['hospitalized'].tolist()

new_hospitalized = mylist
# yo

days = 17
NHC_cases = []
rate = 0.3405 # first 17 days no data give, so assume a rate 34.05%
current_value = 1 # assume on March 1, hospitalization cases = 1
for i in range(days):
    next_value = current_value * math.exp(rate)
    NHC_cases.append(next_value)
    current_value = next_value

# NHC_cases = [round(num) for num in NHC_cases]
# NHC_cases

# To calculate the 7 days, 1 week rate of addition of NHC (New Hopsitalization Cases)
rate = 0
rate_count = 0
NHC_avg_rate = [] 

for i in range(0, len(new_hospitalized) - 1):

    rate += math.log(new_hospitalized[i + 1] / new_hospitalized[i])
    rate_count += 1        #count every iteration

    if rate_count == 7:     #once count is equal to a week, caluclate average rate
        NHC_avg_rate.append(rate / 7)
        rate = 0
        rate_count = 0

# To generate NHC based on 1-week rate change
count = 0
NHC_cases_1 = []
pp = NHC_cases[16]
# pp

for i in range(0,len(new_hospitalized)-1):
    # print(i)
    rate = NHC_avg_rate[count // 7]
    # print(rate)
    nn = pp * math.exp(rate)
    NHC_cases_1.append(nn)
    pp = nn

    count+=1
    if count // 7 >= len(NHC_avg_rate):
        break

NHC_total_cases = NHC_cases + NHC_cases_1
NHC_total_cases = [round(num,2) for num in NHC_total_cases]
# NHC_total_cases

def testing_DTMC(Transition_matrix, NHC_List):
 
    '''
    args:
    NHC_List (List) = Generated by Log Function
    Total_simulations = No of simulations to be conducted

    returns:
    DTMC_predicted_values (NumPy array) = Predicted values, Transitions Probability Matrix

    '''
    DTMC_predicted_values = []

    DTMC_sub_array = [] # [Array[*Array*]]

    for i in range(4):
        DTMC_sub_array.append([])     #creating list inside list

    value = NHC_List[0]
    current_state = np.matrix([value, 0, 0, 0])
    current_state = np.squeeze(np.asarray(current_state))   

    DTMC_sub_array[0].append(current_state[0])
    DTMC_sub_array[1].append(current_state[1])
    DTMC_sub_array[2].append(current_state[2])
    DTMC_sub_array[3].append(current_state[3])

    # iteration 1
    n_state = current_state * Transition_matrix
    n_state = np.squeeze(np.asarray(n_state)) 

    DTMC_sub_array[0].append(NHC_List[1])
    DTMC_sub_array[1].append(n_state[1])
    DTMC_sub_array[2].append(n_state[2])
    DTMC_sub_array[3].append(n_state[3])

    for i in range(1, len(NHC_List)):

        current_state = np.matrix([NHC_List[i], DTMC_sub_array[1][i-1], DTMC_sub_array[2][i-1], DTMC_sub_array[3][i-1]])
        new_state = current_state * Transition_matrix #Markov Chain
        new_state = np.squeeze(np.asarray(new_state)) 

        DTMC_sub_array[0].append(NHC_List[i])
        DTMC_sub_array[1].append(new_state[1])
        DTMC_sub_array[2].append(new_state[2])
        DTMC_sub_array[3].append(new_state[3])

    # Subarrays and respective Transition Probabilities merged
    Transition_matrix = np.squeeze(np.asarray(Transition_matrix))
    DTMC_sub_array.append(Transition_matrix)

    DTMC_predicted_values.append(DTMC_sub_array)

    return DTMC_sub_array
   
   def Trans_Matrix(A):

    # A = np.random.uniform(low = x, high = y)
    # A = np.random.uniform(0.70,0.90,1000)
    all_rows = []
    for i in range(len(A)):
        B_UL = 1 - A[i]
        B_LL = 0
        B = np.random.uniform(low = B_LL , high = B_UL)

        C_UL = 1 - (A[i] + B)
        C_LL = 0
        C = np.random.uniform(low = C_LL, high = C_UL)


        total_sum = A[i] + B + C
        D = 1 - total_sum

        row_values = [A[i], B, C, D]
        all_rows.append(row_values)

    return all_rows
   
   def simulate_DTMC(NHC_total_cases, total_sims):
    
    simulated_values = []

    A1 = np.random.uniform(0.70,0.90,total_sims)
    A2 = np.random.uniform(0.30,0.70,total_sims)

    row1 = Trans_Matrix(A1)
    row2 = Trans_Matrix(A2)

        # load additional module

    for sim in range(0, total_sims):

        TP_matrix = np.matrix([row1[sim], row2[sim], [0, 0,  1,  0], [0, 0,  0,  1]])

        simulated_values.append(testing_DTMC(TP_matrix, NHC_total_cases))

    return [row1, row2, simulated_values]
    
    testmydtmc = simulate_DTMC(NHC_total_cases, 1000)
    
 # load additional module

with open('/Users/pritishsadiga/Desktop/a.txt', 'wb') as filehandle:
    # store the data as binary data stream
    pickle.dump(testmydtmc, filehandle)
   
  # Use the Threshold function to find only the 10% of the lowest distances of the simulation runs

def threshold_acceptance(value):

    l = np.array(value[0])
    threshold = np.percentile(l, 10) # calculate the 10th percentile
    a = l[l < np.percentile(l, 10)] # Filter the list.

    index_list = []
    for i in range(len(a)):
        index_list.append(np.where(l == a[i]))

    index_final_list = []
    for i in range(len(index_list)):
        index_final_list.append(index_list[i][0][0])

    C_accepted = []
    for index in index_final_list:
        C_accepted.append(value[1][index])

    return [a, np.array(C_accepted)]

def POSTERIOR(observed_values, simulated_values):
    
    x = observed_values
    y = simulated_values
    length = len(y)

    C_obs = np.array(x[1][0])
    R_obs = np.array(x[2][0])
    D_obs = np.array(x[3][0])

    C_distances = [[],[]]
    R_distances = [[],[]]
    D_distances = [[],[]]
    
   
    for i in range(0, length):

        C_dist = np.linalg.norm(C_obs - np.array(y[i][1])) # calculate distance
        C_distances[0].append(C_dist)
        C_distances[1].append(y[i][4])

        R_dist = np.linalg.norm(R_obs - np.array(y[i][2])) # calculate distance
        R_distances[0].append(R_dist)
        R_distances[1].append(y[i][4])

        D_dist = np.linalg.norm(D_obs - np.array(y[i][3])) # calculate distance
        D_distances[0].append(D_dist)
        D_distances[1].append(y[i][4])
    
    # Use the Threshold function 
    C_accepted = threshold_acceptance(C_distances) 
    R_accepted = threshold_acceptance(R_distances)
    D_accepted = threshold_acceptance(D_distances)
    
    return [C_accepted, R_accepted, D_accepted]

 value = POSTERIOR(observed_values, testmydtmc)
 
 def calculate_parameters(matrix, total_values):    

    '''
    args:
        matrix = Accepted Parameter Values of Trasnition Matrix 
        total_values = Total number of accepted values (10th percentile)
    returns:
        list[[All accepted values 1st row],[All accepted values 2nd row], [Average values of 1st row], [Average values of 2nd row]]
    '''

    sum_H_H = 0
    HH_list = []
    for i in range(len(matrix)):
        HH_list.append(matrix[i][0][0])   # to create the list of all accepted P(H|H) values 
        sum_H_H += matrix[i][0][0]
    avg_sum_H_H = sum_H_H / total_values
    hh = round(avg_sum_H_H,4)

    sum_C_H = 0
    CH_list = []
    for i in range(len(matrix)):
        CH_list.append(matrix[i][0][1])   # to create the list of all accepted P(C|H) values 
        sum_C_H += matrix[i][0][1]
    avg_sum_C_H = sum_C_H / total_values
    ch = round(avg_sum_C_H,4)

    sum_R_H = 0
    RH_list = []
    for i in range(len(matrix)):
        RH_list.append(matrix[i][0][2])   # to create the list of all accepted P(H|H) values 
        sum_R_H += matrix[i][0][2]
    avg_sum_R_H = sum_R_H / total_values
    rh = round(avg_sum_R_H,4)

    sum_D_H = 0
    DH_list = []
    for i in range(len(matrix)):
        DH_list.append(matrix[i][0][3])   # to create the list of all accepted P(H|H) values 
        sum_D_H += matrix[i][0][3]
    avg_sum_D_H = sum_D_H / total_values
    dh = round(avg_sum_D_H,4)

    #----------------------------------------
    sum_H_C = 0
    HC_list = []
    for i in range(len(matrix)):
        HC_list.append(matrix[i][1][0])   # to create the list of all accepted P(H|H) values 
        sum_H_C += matrix[i][1][0]
    avg_sum_H_C = sum_H_C / total_values
    hc = round(avg_sum_H_C,4)

    sum_C_C = 0
    CC_list = []
    for i in range(len(matrix)):
        CC_list.append(matrix[i][1][1])   # to create the list of all accepted P(H|H) values 
        sum_C_C += matrix[i][1][1]
    avg_sum_C_C = sum_C_C / total_values
    cc = round(avg_sum_C_C,4)

    sum_R_C = 0
    RC_list = []
    for i in range(len(matrix)):
        RC_list.append(matrix[i][1][2])   # to create the list of all accepted P(H|H) values 
        sum_R_C += matrix[i][1][2]
    avg_sum_R_C = sum_R_C / total_values
    rc = round(avg_sum_R_C,4)

    sum_D_C = 0
    DC_list = []
    for i in range(len(matrix)):
        DC_list.append(matrix[i][1][3])   # to create the list of all accepted P(H|H) values 
        sum_D_C += matrix[i][1][3]
    avg_sum_D_C = sum_D_C / total_values
    dc = round(avg_sum_D_C,4)

    return [[HH_list, CH_list, RH_list, DH_list], [HC_list, CC_list, RC_list, DC_list], [hh, ch, rh, dh], [hc, cc, rc, dc]]
   
C = calculate_parameters(value[0][1],100)
R = calculate_parameters(value[1][1],100)
D = calculate_parameters(value[2][1],100)

HH_sum = C[0][0] + R[0][0] + D[0][0]
CH_sum = C[0][1] + R[0][1] + D[0][1]
RH_sum = C[0][2] + R[0][2] + D[0][2]
DH_sum = C[0][3] + R[0][3] + D[0][3]

HC_sum = C[1][0] + R[1][0] + D[0][0]
CC_sum = C[1][1] + R[1][1] + D[0][1]
RC_sum = C[1][2] + R[1][2] + D[0][2]
DC_sum = C[1][3] + R[1][3] + D[0][3]

def plot_posterior(probability_list,title):

    plt.hist(probability_list, bins = 35, alpha = 0.5)    
    plt.title(title)
    plt.xlabel('Probabilities')
    plt.ylabel('Count')
    plt.legend()
    plt.rcParams['figure.figsize']= [8,4]

    return plt.show()
  
  # Plotting Posterior Distribution of all accepted parameters of Transition Matrix

plot_posterior(HH_sum,'Posterior: P(H|H)')
plot_posterior(CH_sum,'Posterior: P(C|H)')
plot_posterior(RH_sum,'Posterior: P(R|H)')
plot_posterior(DH_sum,'Posterior: P(D|H)')

# Plotting Posterior Distribution of all accepted parameters of Transition Matrix

plot_posterior(HC_sum,'Posterior: P(H|C)')
plot_posterior(CC_sum,'Posterior: P(C|C)')
plot_posterior(RC_sum,'Posterior: P(R|C)')
plot_posterior(DC_sum,'Posterior: P(D|C)')

row_1 = [C[0],R[0],D[0]]
row_2 = [C[1],R[1],D[1]]

array_1 = [np.array(x) for x in row_1]
array_2 = [np.array(x) for x in row_2]

# caculate mean parameter values 
mean_row1 = [np.mean(k) for k in zip(*array_1)]
mean_row2 = [np.mean(k) for k in zip(*array_2)]

# Final Transition Probability Matrix:
Modeled_TP_Matrix_10000 = np.matrix([ [round(num,4) for num in mean_row1], 
                                [round(num,4) for num in mean_row2],
                                [0, 0, 1, 0],
                                [0, 0, 0, 1]])
Modeled_TP_Matrix_10000

# For 10000 simulations
Modeled_TP_Matrix_10000
